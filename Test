flask_app/
│
├── app/
│   ├── __init__.py
│   ├── extensions.py
│   ├── models.py
│   │
│   ├── routes/
│   │   ├── __init__.py
│   │   ├── auth_routes.py
│   │   ├── property_routes.py
│   │   └── community_routes.py
│   │
│   ├── static/
│   │   └── uploads/
│   │
│   └── config.py
│
├── run.py
└── requirements.txt



run.py
from app import create_app

app = create_app()

if __name__ == "__main__":
    app.run(debug=True)


app/init.py
import os
from flask import Flask
from .extensions import db, jwt
from .routes.auth_routes import auth_bp
from .routes.property_routes import property_bp
from .routes.community_routes import community_bp

def create_app():
    app = Flask(__name__)

    app.config.from_object("app.config.Config")

    # Initialize extensions
    db.init_app(app)
    jwt.init_app(app)

    # Register blueprints
    app.register_blueprint(auth_bp, url_prefix="/api/auth")
    app.register_blueprint(property_bp, url_prefix="/api")
    app.register_blueprint(community_bp, url_prefix="/api")

    # Ensure upload folder exists
    os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)

    with app.app_context():
        db.create_all()

    return app

app/config.py
import os

class Config:
    SECRET_KEY = "your_secret_key_here"
    SQLALCHEMY_DATABASE_URI = "sqlite:///database.db"
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    JWT_SECRET_KEY = "your_jwt_secret_key_here"
    UPLOAD_FOLDER = os.path.join(os.getcwd(), "app", "static", "uploads")

app/extension.py
from flask_sqlalchemy import SQLAlchemy
from flask_jwt_extended import JWTManager

db = SQLAlchemy()
jwt = JWTManager()


app/model.py
from datetime import datetime
from .extensions import db
from werkzeug.security import generate_password_hash, check_password_hash


class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(50), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(200), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    properties = db.relationship('Property', backref='owner', lazy=True)
    communities = db.relationship('Community', backref='creator', lazy=True)

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)


class Property(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(120), nullable=False)
    description = db.Column(db.Text)
    price = db.Column(db.Float, nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)


class Community(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(120), nullable=False)
    description = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)

    images = db.relationship('CommunityImage', backref='community', lazy=True)


class CommunityImage(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    image_url = db.Column(db.String(200), nullable=False)
    community_id = db.Column(db.Integer, db.ForeignKey('community.id'), nullable=False)


aut_route.py
from flask import Blueprint, request, jsonify
from app.extensions import db
from app.models import User
from flask_jwt_extended import create_access_token

auth_bp = Blueprint("auth", __name__)

@auth_bp.route("/register", methods=["POST"])
def register():
    data = request.get_json()
    if not all(k in data for k in ("username", "email", "password")):
        return jsonify({"error": "Missing fields"}), 400

    if User.query.filter((User.username == data["username"]) | (User.email == data["email"])).first():
        return jsonify({"error": "Username or email already exists"}), 400

    user = User(username=data["username"], email=data["email"])
    user.set_password(data["password"])
    db.session.add(user)
    db.session.commit()

    return jsonify({"message": "User registered successfully"}), 201


@auth_bp.route("/login", methods=["POST"])
def login():
    data = request.get_json()
    user = User.query.filter_by(email=data.get("email")).first()

    if not user or not user.check_password(data.get("password")):
        return jsonify({"error": "Invalid credentials"}), 401

    token = create_access_token(identity=user.id)
    return jsonify({"token": token, "username": user.username, "user_id": user.id})


community_route.py

from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from app.extensions import db
from app.models import Property

property_bp = Blueprint("property", __name__)

@property_bp.route("/properties", methods=["POST"])
@jwt_required()
def create_property():
    user_id = get_jwt_identity()
    data = request.get_json()
    if not all(k in data for k in ("title", "price")):
        return jsonify({"error": "Missing title or price"}), 400

    prop = Property(
        title=data["title"],
        description=data.get("description", ""),
        price=data["price"],
        user_id=user_id
    )
    db.session.add(prop)
    db.session.commit()

    return jsonify({"message": "Property created"}), 201


@property_bp.route("/properties", methods=["GET"])
def list_properties():
    props = Property.query.all()
    result = []
    for p in props:
        result.append({
            "id": p.id,
            "title": p.title,
            "description": p.description,
            "price": p.price,
            "owner": {
                "id": p.owner.id,
                "username": p.owner.username,
                "email": p.owner.email
            }
        })
    return jsonify(result)


@property_bp.route("/my-properties", methods=["GET"])
@jwt_required()
def my_properties():
    user_id = get_jwt_identity()
    props = Property.query.filter_by(user_id=user_id).all()
    result = [{"id": p.id, "title": p.title, "description": p.description, "price": p.price} for p in props]
    return jsonify(result)


@property_bp.route("/properties/<int:user_id>", methods=["GET"])
def get_properties_by_user(user_id):
    props = Property.query.filter_by(user_id=user_id).all()
    if not props:
        return jsonify({"message": "No properties found"}), 404

    result = []
    for p in props:
        result.append({
            "id": p.id,
            "title": p.title,
            "description": p.description,
            "price": p.price,
            "owner": {
                "id": p.owner.id,
                "username": p.owner.username,
                "email": p.owner.email
            }
        })
    return jsonify(result)

requirement
Flask==3.0.3
Flask-JWT-Extended==4.6.0
Flask-SQLAlchemy==3.1.1
Werkzeug==3.0.2

profile

# routes/profile_routes.py

from flask import Blueprint, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from ..models import User

profile_bp = Blueprint('profile', __name__)

@profile_bp.route('/me', methods=['GET'])
@jwt_required()
def get_profile():
    user_id = get_jwt_identity()
    user = User.query.get(user_id)

    if not user:
        return jsonify({"error": "User not found"}), 404

    response = {
        "id": user.id,
        "username": user.username,
        "email": user.email,
        "created_at": user.created_at,
        
        # ✅ User's Properties
        "properties": [
            {
                "id": p.id,
                "title": p.title,
                "description": p.description,
                "price": p.price,
                "created_at": p.created_at
            } for p in user.properties
        ],

        # ✅ User's Communities with images
        "communities": [
            {
                "id": c.id,
                "name": c.name,
                "description": c.description,
                "created_at": c.created_at,
                "images": [
                    {
                        "id": img.id,
                        "image_url": img.image_url,
                        "community_id": img.community_id
                    } for img in c.images
                ]
            } for c in user.communities
        ]
    }

    return jsonify(response), 200






import os
from flask import Blueprint, request, jsonify, current_app
from flask_jwt_extended import jwt_required, get_jwt_identity
from werkzeug.utils import secure_filename
from app.extensions import db
from app.models import Community, CommunityImage

community_bp = Blueprint("community", __name__)

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in {"png", "jpg", "jpeg"}

@community_bp.route("/communities", methods=["POST"])
@jwt_required()
def create_community():
    user_id = get_jwt_identity()
    name = request.form.get("name")
    description = request.form.get("description")

    if not name:
        return jsonify({"error": "Community name required"}), 400

    community = Community(name=name, description=description, user_id=user_id)
    db.session.add(community)
    db.session.commit()

    # Save uploaded images
    files = request.files.getlist("images")
    image_urls = []
    for file in files:
        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            filepath = os.path.join(current_app.config["UPLOAD_FOLDER"], filename)
            os.makedirs(current_app.config["UPLOAD_FOLDER"], exist_ok=True)
            file.save(filepath)
            rel_path = f"/static/uploads/{filename}"
            db.session.add(CommunityImage(image_url=rel_path, community_id=community.id))
            image_urls.append(rel_path)
    db.session.commit()

    return jsonify({
        "message": "Community created successfully",
        "community": {
            "id": community.id,
            "name": community.name,
            "description": community.description,
            "images": image_urls
        }
    }), 201


@community_bp.route("/communities", methods=["GET"])
def list_communities():
    communities = Community.query.all()
    result = []
    for c in communities:
        result.append({
            "id": c.id,
            "name": c.name,
            "description": c.description,
            "creator": {
                "id": c.creator.id,
                "username": c.creator.username,
                "email": c.creator.email
            },
            "images": [img.image_url for img in c.images]
        })
    return jsonify(result)


@community_bp.route("/my-communities", methods=["GET"])
@jwt_required()
def my_communities():
    user_id = get_jwt_identity()
    communities = Community.query.filter_by(user_id=user_id).all()
    result = []
    for c in communities:
        result.append({
            "id": c.id,
            "name": c.name,
            "description": c.description,
            "images": [img.image_url for img in c.images]
        })
    return jsonify(result)


@community_bp.route("/communities/<int:user_id>", methods=["GET"])
def get_communities_by_user(user_id):
    communities = Community.query.filter_by(user_id=user_id).all()
    if not communities:
        return jsonify({"message": "No communities found"}), 404

    result = []
    for c in communities:
        result.append({
            "id": c.id,
            "name": c.name,
            "description": c.description,
            "creator": {
                "id": c.creator.id,
                "username": c.creator.username,
                "email": c.creator.email
            },
            "images": [img.image_url for img in c.images]
        })
    return jsonify(result)







import os
import json
import base64
from io import BytesIO

from flask import Blueprint, request, Response, jsonify
from google import genai
from google.genai import types
from PIL import Image
from dotenv import load_dotenv

load_dotenv()
api_bp = Blueprint("api", __name__)
client = genai.Client(api_key=os.getenv("GEMINI_API_KEY"))

def convert_history_to_contents(history):
    """
    Convert frontend history (JSON) into Gemini API 'contents',
    including text & images in correct order.
    """
    contents = []
    for item in history:
        parts = []
        # text
        if item["type"].endswith("_text"):
            parts.append(types.Part(text=item["text"]))
        # image
        elif item["type"].endswith("_image"):
            img_bytes = base64.b64decode(item["base64"])
            image_obj = Image.open(BytesIO(img_bytes)).convert("RGB")
            parts.append(image_obj)

        role = "user" if item["type"].startswith("user") else "model"
        contents.append(types.Content(role=role, parts=parts))
    return contents

@api_bp.post("/upload_and_stream")
def upload_and_stream():
    """
    Accepts:
    - multipart image upload
    - prompt text
    - history (JSON list of chat blocks)

    Returns an SSE stream of text & image events.
    """
    prompt = request.form.get("prompt", "").strip()
    history_json = request.form.get("history", "[]")

    try:
        history = json.loads(history_json)
    except json.JSONDecodeError:
        return jsonify({"error": "Invalid history JSON"}), 400

    # Convert user history into Gemini contents
    contents = convert_history_to_contents(history)

    # — Add uploaded image if provided
    file = request.files.get("image")
    if file:
        # Convert file to PIL
        pil_img = Image.open(file.stream).convert("RGB")
        contents.append(types.Content(role="user", parts=[pil_img]))

    # — Finally user text prompt
    contents.append(types.Content(role="user", parts=[types.Part(text=prompt)]))

    def event_stream():
        """
        Loops through Gemini streaming API and yields SSE events:
        event: text → plain text tokens
        event: image → base64 of generated images
        event: done → end signal
        """
        stream = client.models.generate_content_stream(
            model="gemini-2.5-flash-image",
            contents=contents,
            config=types.GenerateContentConfig(response_modalities=["TEXT", "IMAGE"])
        )

        for chunk in stream:
            # — TEXT streaming
            if getattr(chunk, "text", None):
                yield f"event: text\ndata: {chunk.text}\n\n"

            # — IMAGE streaming
            for part in getattr(chunk, "parts", []):
                if part.inline_data:
                    b64 = base64.b64encode(part.inline_data.data).decode("utf-8")
                    yield f"event: image\ndata: {b64}\n\n"

        # — done
        yield "event: done\ndata: done\n\n"

    return Response(event_stream(), mimetype="text/event-stream")






import React, { useState, useRef } from "react";
import axios from "axios";
import "./App.css";

function App() {
  const [prompt, setPrompt] = useState("");
  const [selectedFile, setSelectedFile] = useState(null);
  const [history, setHistory] = useState([]);
  const [streaming, setStreaming] = useState(false);

  const messagesEndRef = useRef(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  const sendMessage = async () => {
    if (!prompt && !selectedFile) return;

    // Add user message to history
    const newHistory = [
      ...history,
      { type: "user_text", text: prompt },
    ];
    if (selectedFile) {
      const reader = new FileReader();
      reader.onloadend = () => {
        newHistory.push({
          type: "user_image",
          base64: reader.result.split(",")[1],
        });
        setHistory(newHistory);
        startSSE(newHistory);
      };
      reader.readAsDataURL(selectedFile);
    } else {
      setHistory(newHistory);
      startSSE(newHistory);
    }

    setPrompt("");
    setSelectedFile(null);
  };

  const startSSE = async (historyForRequest) => {
    setStreaming(true);

    // Build FormData with prompt, file (if any), and history JSON
    const formData = new FormData();
    formData.append("prompt", prompt);
    formData.append("history", JSON.stringify(historyForRequest));
    if (selectedFile) {
      formData.append("image", selectedFile);
    }

    try {
      // Kick off SSE connection
      const source = new EventSourcePolyfill("/api/upload_and_stream", {
        headers: {
          "Accept": "text/event-stream",
        },
        body: formData,
      });

      let bufferText = "";

      source.addEventListener("text", (e) => {
        bufferText += e.data;
        setHistory((prev) => [
          ...prev.filter((m) => m.temp !== true),
          { type: "assistant_text", text: bufferText, temp: true },
        ]);
        scrollToBottom();
      });

      source.addEventListener("image", (e) => {
        // Remove temporary text if present
        setHistory((prev) => prev.filter((m) => !m.temp));

        setHistory((prev) => [
          ...prev,
          { type: "assistant_image", base64: e.data },
        ]);
        scrollToBottom();
      });

      source.addEventListener("done", () => {
        setStreaming(false);
        source.close();
      });

    } catch (error) {
      console.error("SSE error", error);
      setStreaming(false);
    }
  };

  return (
    <div className="App">
      <div className="chat-container">
        {history.map((msg, idx) => (
          <Message key={idx} message={msg} />
        ))}
        <div ref={messagesEndRef} />
      </div>

      <div className="input-container">
        <input
          type="text"
          placeholder="Type your message..."
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          disabled={streaming}
        />

        <input
          type="file"
          accept="image/*"
          onChange={(e) => setSelectedFile(e.target.files[0])}
          disabled={streaming}
        />

        <button onClick={sendMessage} disabled={streaming}>
          {streaming ? "Generating..." : "Send"}
        </button>
      </div>
    </div>
  );
}

function Message({ message }) {
  if (message.type === "user_text") {
    return <div className="msg user">{message.text}</div>;
  }
  if (message.type === "assistant_text") {
    return <div className="msg ai">{message.text}</div>;
  }
  if (message.type === "user_image") {
    return (
      <div className="msg user">
        <img
          src={"data:image/png;base64," + message.base64}
          alt="User Upload"
        />
      </div>
    );
  }
  if (message.type === "assistant_image") {
    return (
      <div className="msg ai">
        <img
          src={"data:image/png;base64," + message.base64}
          alt="AI Response"
        />
      </div>
    );
  }
  return null;
}

export default App;









.App {
  font-family: Arial, sans-serif;
  width: 800px;
  margin: auto;
  display: flex;
  flex-direction: column;
}

.chat-container {
  flex: 1;
  max-height: 75vh;
  overflow-y: auto;
  padding: 10px;
  border: 1px solid #ccc;
}

.msg {
  margin: 10px 0;
  padding: 8px;
  border-radius: 8px;
  max-width: 70%;
}

.user {
  background: #daf8cb;
  align-self: flex-end;
}

.ai {
  background: #f1f1f1;
  align-self: flex-start;
}

input[type="text"] {
  width: 60%;
  padding: 8px;
  margin-right: 10px;
}

input[type="file"] {
  margin-right: 10px;
}

button {
  padding: 8px 16px;
}
